---
title: 理解Thread类
date: 2018-04-11 21:53:22
tags: [多线程,java]
categories: [java源码阅读]
---
> `Thread`类是对`CPU`执行代码的一种抽象。可以将`Thread`对象和车床工人做一下对比，假设某工厂有多个工人但只有一台车床，老板将多个任务分给工人，按照我们的思维，多个工人将围绕这台车床展开工作，老板负责合理的安排工人使用车床的时间。所以研究`Thread`类就像研究工人为完成工作而表现出来的行为。

# 线程的状态
围绕着`CPU`的执行机会，线程将这样一些状态：
1. 就绪。任务分配后，工人们各自找到了自己的原材料，然后告诉老板我准备好了，可以工作了，然后排队。反映在`Thread`对象上，相当于创建了线程，分配了栈空间以及准备了其他运行所需要的条件，等待`CPU`的空闲。
2. 运行。某个工人准备工作都做好了，而恰好此时车床市空闲的，所以老板就安排了他去工作。`CPU`处于空闲状态，系统安排线程去使用`CPU`。
3. 阻塞。工人在使用车床的时候发现自己的材料需要打磨，就去钳工台了，让出了车床。线程在执行过程中需要等待`IO`或着`synchronized锁`等资源，放弃了`CPU`资源。
4. 睡眠。工人工作累了离开车床休息会，并给自己定了闹钟，过一段时间再来工作。线程等待一段时间。
5. 等待。A工人的工作需要等B工人作出零件后才能进行，所以让出车床等待B工人完成零件。线程睡眠，等待其他线程唤醒。
6. 停止。完成工作或者被迫停止。

线程状态图如下：
![线程状态图](线程状态图.png)

# 一些属性
`Thread`类对线程进行了封装和抽象，对外表现出一些行为和状态，其中就包括线程名称、线程ID、优先级、是否守护线程、执行任务等等。

## daemon
这类线程并不是用户线程不可或缺的部分，只是用于提供服务的"服务线程"。 基于这个特点，当虚拟机中的用户线程全部退出运行时，守护线程没有服务的对象后，JVM也就退出了。比如说垃圾回收线程。
```java 
public class NewTread extends Thread {
    @Override
    public void run() {
        while (true)
            System.out.println(getName() + "线程正在运行...");
    }

    public static void main(String[] args) {
        Thread t = new NewTread();
        //实际上2s后程序退出。如果t不是守护线程，那么程序永远不会退出
        t.setDaemon(true);
        t.start();
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }
}
```  
## target
